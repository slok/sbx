### Task 5: Exec Command

**Goal:** Execute commands inside running sandboxes.

**Context:** With Docker engine and task system working, we can now run commands inside containers. This is essential for agentic workflows — the agent needs to execute code, run tests, install packages. The exec capability is added to the engine interface and implemented for Docker.

**Deliver:**

1. Add `Exec` method to engine interface
2. Docker engine exec implementation at `internal/sandbox/docker/`
3. Fake engine exec implementation (for unit tests)
4. `sbx exec` CLI command
5. `sbx shell` CLI command (convenience wrapper)

**Engine interface addition:**

```
Exec(id, command, opts) -> ExecResult
```

ExecResult:
- ExitCode (int)
- Stdout (string or stream)
- Stderr (string or stream)

ExecOpts:
- WorkingDir (string) — directory to run command in
- Env (map) — additional env vars for this exec
- Stdin (reader) — optional stdin input
- Tty (bool) — allocate TTY (for shell)

**CLI:**

```bash
# Run command
sbx exec my-sandbox -- ls -la
sbx exec my-sandbox -- go build ./...
sbx exec my-sandbox --workdir /app -- npm install

# With env vars
sbx exec my-sandbox --env FOO=bar -- echo $FOO

# Interactive shell
sbx shell my-sandbox
# Equivalent to: sbx exec my-sandbox --tty -- /bin/sh
```

**Output behavior:**

- Stream stdout/stderr in real-time (not buffered)
- Exit code propagates to CLI exit code
- `sbx exec` returns non-zero if command fails

**Docker implementation:**

Delegate to `docker exec` and wire stdin/stdout/stderr:

```
cmd = exec.Command("docker", "exec", containerID, "ls", "-la")
cmd.Stdin = os.Stdin
cmd.Stdout = os.Stdout
cmd.Stderr = os.Stderr
cmd.Run()
```

For interactive shell with TTY:

```
cmd = exec.Command("docker", "exec", "-it", containerID, "/bin/sh")
cmd.Stdin = os.Stdin
cmd.Stdout = os.Stdout
cmd.Stderr = os.Stderr
cmd.Run()
```

Docker handles all TTY complexity. The CLI just passes through the streams.

**Validation:**

- Sandbox must exist
- Sandbox must be running (status = running)
- Command must not be empty

**Fake engine implementation:**

For unit tests, fake engine should:
- Accept exec calls on "running" sandboxes
- Return configurable responses (for testing success/failure)
- Reject exec on non-running sandboxes

**Tests required:**

- Unit tests with fake engine
- Exec on running sandbox succeeds
- Exec on stopped sandbox fails
- Exit code propagation
- Stdout/stderr streaming
- Working directory option
- Env vars passed correctly
- Integration tests with Docker (real exec)

**Out of scope:**

- File copy
- Long-running background processes
- Firecracker exec (comes with Firecracker engine)