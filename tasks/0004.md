### Task 4: Task System

**Goal:** Add a simple checkpoint log for multi-step operations with crash recovery and progress tracking.

**Context:** Complex operations involve multiple steps. If the CLI crashes mid-operation, we need to know where we stopped. The task system is just a log — track what task we're on, resume if crashed, show progress.

**Deliver:**

1. Tasks table in SQLite
2. Task manager package at `internal/task/`
3. Progress tracking
4. Crash recovery (find last done task, resume)
5. Integration with existing commands

**Schema:**

**tasks** table:

| Field | Type | Notes |
|-------|------|-------|
| ID | string | ULID |
| SandboxID | string | FK to sandboxes |
| Operation | string | create, start, stop, remove |
| Sequence | int | Auto-increment |
| Name | string | pull_image, create_container, etc. |
| Status | string | pending, done, failed |
| Error | string | if failed |
| CreatedAt | time | |

**Interface:**

```
// Setup
AddTask(sandbox_id, operation, name)  // sequence auto-assigned
AddTasks(sandbox_id, operation, []name)  // batch add

// Execution
NextTask(sandbox_id, operation) -> Task  // first pending task
CompleteTask(task_id)
FailTask(task_id, error)

// Progress
Progress(sandbox_id, operation) -> (done int, total int)

// Recovery
HasPendingOperation(sandbox_id) -> (operation, bool)

// Cleanup
ClearOperation(sandbox_id, operation)
```

**Usage pattern:**

```
// 1. Add all tasks upfront
AddTasks(sandbox_id, "create", ["pull_image", "create_container"])

// 2. Execute tasks in order
for {
    task = NextTask(sandbox_id, "create")
    if task == nil:
        break  // all done
    
    err = executeTask(task)
    if err:
        FailTask(task.ID, err)
        return
    CompleteTask(task.ID)
}

// 3. Cleanup
ClearOperation(sandbox_id, "create")
```

**Example: Docker operations**

| Operation | Tasks |
|-----------|-------|
| create | pull_image, create_container |
| start | start_container |
| stop | stop_container |
| remove | remove_container |

**Example: Firecracker operations (future, not this task)**

This shows why the task system matters — Firecracker has multi-step operations where crash recovery is critical:

| Operation | Tasks |
|-----------|-------|
| create | create_overlay, create_tap, setup_iptables, write_config, spawn_firecracker, configure_vm |
| start | boot_vm |
| stop | shutdown_vm, kill_process |
| remove | cleanup_iptables, delete_tap, delete_overlay, delete_socket |

If CLI crashes after `create_tap` but before `setup_iptables`, recovery can resume at the next pending task instead of starting over (and leaking a TAP device).

**Crash recovery:**

```
op, pending = HasPendingOperation(sandbox_id)
if pending:
    // Resume — NextTask will return first pending task
    task = NextTask(sandbox_id, op)
    ...
```

**Progress output:**

```
Creating sandbox: my-sandbox
[2/4] Creating container... ████████░░░░ 50%
```

**Tests required:**

- AddTask / AddTasks
- NextTask returns tasks in sequence order
- NextTask returns nil when all done
- CompleteTask / FailTask status updates
- Progress counting
- HasPendingOperation detects incomplete operations
- Recovery simulation
- ClearOperation cleanup

**Out of scope:**

- Rollback automation
- Parallel tasks