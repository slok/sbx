### Task 3: Docker Engine

**Goal:** Implement a real sandbox engine using Docker containers.

**Context:** Docker provides container-based sandboxes that work anywhere — CI, Mac, Linux without KVM. Not as isolated as microVMs but uses the same engine interface. This lets us validate the full lifecycle with real processes before adding Firecracker.

**Requirements:**

- Docker installed and running
- User in `docker` group (or root)

**Deliver:**

1. Update SandboxConfig to support engine-specific configuration
2. Docker engine implementing the engine interface at `internal/sandbox/docker/`
3. Container lifecycle: create, start, stop, remove
4. Process/container state checking
5. Base image handling (pull from Docker Hub)

**Updated SandboxConfig:**

```yaml
name: test-sandbox
engine:
  docker:
    image: ubuntu:22.04
#  firecracker:
#    root_fs: /path/to/rootfs.ext4
#    kernel_image: /path/to/vmlinux
packages:
  - curl
  - git
env:
  FOO: bar
  DEBUG: "true"
resources:
  vcpus: 2
  memory_mb: 2048
  disk_gb: 10
```

- Only one engine block allowed (docker OR firecracker)
- Engine-specific settings live under their key
- Common settings (packages, env, resources) apply to all engines

**Package structure:**

```
internal/sandbox/
├── engine.go           # Engine interface (from Task 1)
├── fake/
│   └── engine.go       # Fake engine (from Task 1)
└── docker/
    └── engine.go       # Docker engine implementation
```

**Engine interface (from Task 1):**

- `Create(cfg) -> Sandbox`
- `Start(id)`
- `Stop(id)`
- `Remove(id)`
- `Status(id) -> Sandbox`

**Mapping config to Docker:**

| SandboxConfig | Docker equivalent |
|---------------|-------------------|
| Name | Container name: `sbx-<sandbox-id>` |
| engine.docker.image | Image (e.g., `ubuntu:22.04`) |
| Packages | Ignored for now (baked in image) |
| Env | Environment variables (`-e`) |
| Resources.VCPUs | `--cpus` |
| Resources.MemoryMB | `--memory` |

**Sandbox model additions:**

Add to Sandbox model:

- ContainerID (string) — Docker container ID

**State mapping:**

| Docker state | Sandbox status |
|--------------|----------------|
| created | pending |
| running | running |
| exited | stopped |
| dead | failed |
| not found | failed |

**Tests required:**

- Unit tests with mocked Docker client
- Integration tests with real Docker (CI compatible)
- Config parsing with engine block
- Validation: only one engine allowed
- Create → Start → Stop → Remove lifecycle
- Status correctly reflects container state
- Resource limits applied

**CI Integration:**

This engine will be used heavily in CI for integration tests. GitHub Actions has Docker pre-installed.

- Set up GitHub Actions workflow for integration tests
- Integration tests must use the Docker engine with real containers
- Tests should create, run, and cleanup containers properly
- Handle test isolation (parallel tests shouldn't conflict)
- Clean up containers on test failure (defer cleanup)

Use a PR to iterate on CI until integration tests pass reliably. This is expected — CI debugging often takes multiple iterations.

**Test tagging:**

Separate unit and integration tests so they can run independently:

- Unit tests: fast, no external deps, run always
- Integration tests: require Docker, tagged or in separate directory

**Out of scope:**

- Networking (port forwarding)
- File copy into container
- SSH access (containers use exec instead)
- Firecracker engine (next task)
- Package installation (later task)